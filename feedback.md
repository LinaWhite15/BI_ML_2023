# 1. EDA
## 1.1
Ты не реализовала график со всеми классами. Синтаксим не очень сложный, и он есть в документации.

Помимо того, что написано в [документации](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.subplots.html), для лучшей визуализации может быть удобнее отключать отображение осей на картинках, как вариант:
```{python}
axis_index = <индекс рисунка, который ты делаешь>

axs[axis_index].imshow(image)
axs[axis_index].set_title(<lable of a subplot>)
axs[axis_index].axis("off")
```
И тут же заодно лучше переиспользовать вычисление переменной, чтобы не запутаться

## 1.2
Баланс классов у тебя реализован достаточно просто, и в таком виде информацию сложно поглощать. Я советую такие вещи делать в виде графика. Снимаю четверть балла, так как на работе и в реальной практике очень важно иметь отчеты, которые сами за себя говорят, потому что времени разбираться, что сделал человек, и какой у него код написан, не всегда много. И если я не знаю синтаксис `np.unique`, то я в жизни не разберусь, что там показано. За это снимаю еще четверть балла - так репортить нельзя.

## 1.3
Вопросов нет, сплит реализован корректно, еще мне понравилось, как ты сделала кастинг типов - оч круто! Но я бы лучше использовал все же заготовленный сид `SEED`, а не свой, так как тогда у тебя вся работа будет воспроизводиться с одним сидом.

## 1.4 KNN

- Сортировать необязательно, я бы даже сказал, что совсем не нужно. так как Кто знает, как дальше ты будешь данные сплитить
- Слишком замудреный способ получить два класса, можно много где запутаться. Я советую использовать одну команду для этого - [`np.logical_or`](https://numpy.org/doc/stable/reference/generated/numpy.logical_or.html) - ознакомься пожалуйста, с помощью нее можно в одно действие достать все нужные индессы, а потом по ним сделать реслайс датасета
- Из-за того, как ты делаешь поиск индексов, у тебя уже ест проблемы с размерностями, так как np.where выдал тебе кортеж, а не массив. Поэтому ты пыталась видимо это исправить методом `resize` - но это делать категорически не советую, так как у тебя все данные могут перемешаться и это неэффективно. Лучше уж `reshape`. Но и так, и так это плохо обобщается, потому что ты захардкодила размерности - это тоже нужно учитывать.

Я вынужден снять за это балл, так как это опасная и неэффективная реализация. Никогда не юзай `resize`!!!!! Это очень опасно, все данные перемешаться могут.

В реализации `compute_distances_no_loops` можно обойтись без `np.repeat`, достаточно просто добавить новую ось, как ты и сделала, и numpy автоматически сделает [broadcasting](https://numpy.org/doc/stable/user/basics.broadcasting.html) - и он как правило сделает это эффективнее нашей реализации. Поэтому было бы достаточно написать:

```{python}

distances_raw = self.train_X[np.newaxis, :, :] - X[:, np.newaxis, :] # автоматически сделает все что нужно. При этом у тебя в коде идет ФИЗИЧЕСКОЕ копирование, что намного дольше
distances = np.linalg.norm(distances_raw, axis=2, ord=1)
```

Мне понравилось, как ты изменила степень в `np.linalg.norm`, это очень оригинально! 


Метрики для бинарной классификации реализованы правильно. 
- НО - у тебя реализовано в цикле, что очень неэффективно. Это можно сделать при помощи векторизованных операций нампая, плюс у тебя тут все привязано к строковому типу, хотя до этого ты делала кастинг, а тут ты его делаешь обратно - зачем? Это лишнее.
  - **Переделай в векторый вид, это важно в дальнейшем понимать**
- Еще мне как проверяющемю непонятен вывод - нельзя просто в консоль вывезти без указания, что происходит и что это за объект. Принтом бы хотя бы указала... Так нельзя делать в реальной работе. Снимаю четверть балла. Это еще более критично, когда в твой код нельзя будет залезть и посмотреть (если он к примеру будет проприетарный).

За неэффективную реализациюи лишнее приведение типов снимаю полбалла. В это можно легко запутаться, код должен быть как можно проще.

Предсказания для классов реализованы правильно. Но можно сделать это в векторном виде сразу для всего `X`. Как? Подсказка - заменить операциями из нампая цикл в `predict_labels_binary` и убрать bincount, но посчитать количество скажем класса 1 с помощью бинарной маски (ты похожим образом сделала при индексации классов в самом начале). А маска это массив из числе 0 и 1, соответственно если сложить по одной из осей, то получим количество одного из классов. Если подсказка непонятная, не стесняйся и пиши, объясню подробнее. Но постарайся сделать это без цикла. 


В реальной практике работа аналитика очень важна и должна всегда быть чем-то подкреплена, поэтому там ответ "плюс-минус 20" не прокатит, хотя я и согласен, что после 20 уже идет переобучение (Как это проявляется кстати?). Поэтому я сниму балл за отсутствие объяснения.




- лишняя переменная `accuracy_score` - мы уже передаюм сюда метрику, зачем она нужна?
- Тут же проблема с тем, что ты не используешь параметр `X_test`. Переменная `test_metric` в цикле будет отражать некорректную информацию, ты ей передаешь в оба аргумента `y_test`. А где предсказания для теста?
- Метрика `train_metric` считается некорректно - ты передаешь предсказания для трейна и `y_test`.
- Ты используешь `binary_classification_metrics`, а затем в список кладешь только 4-ю метрику, но ты же метрику можешь передавать как параметр - из-за этого реализация функции может репортить только одну метрику.
- Функция `find_best_k` не запускается, ты не передаешь ей все нужные параметры. Поэтому ячейки с подбором лучшего k у тебя не работают




## 1.5 Multiclass KNN

`find_best_score` реализована некорректно, поэтому все и сломалось.

В твоем коде сломалось отображение метрик и из-за неправильно реализованной функции анализ неудачный. Правильно реализовано предсказание для пногоклассовой классификации, поэтому полбалла за этот пункт ты получаешь. Тоже подумай, как исправить ошибку в функции.



# 2 EDA

## 2.1

Еще можно автоматически подгрузить колонки с нужным тебе типом данных - [`pd.DataFrame.select_dtypes`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.select_dtypes.html), советую ознакомиться! Очень выручала меня. Пример:

```{python}
cat_cols = X.select_dtypes(include="object").columns # оставит колонки со строковым типом

```
- Загрузить нужно `scaled=True` данные, как просится в задании
- В Пайплайне не хватает трансформации для категориальных фичей, так как пол равносилен, то нужно сделать one-hot-encoding

cнял по четверти балла за каждый пункт

## 2.2-2.3

- `multiclass_accuracy` реализована неэффективно, можно сделать на голом нампае
- `r_squared` реализовано неправильно (подсказка - знаменатель)

2/3 метрик правильно - 1.75 баллов из 3 за пункт с метриками (минус четверть балла за неэффективность реализации)

## 2.4
Ну вот тут-то у тебя все правильно сделано в `find_best_k`! Почему там-то не перепроверила? Обидно очень даже... С выбором k согласен, я бы взял k=9.

# 3 Social

За тусу с одногруппами - +rep и обещанный доп полбалла!


Итог:
- 1.1 - 0/0.5 (нет графиков)
- 1.2 - 0.5/1 (неинформативный репорт)
- 1.3 - 0.5/0.5
- 1.4 - 2.25/6 (-1 за реализацию индексов бинарных классов, -0.25 за отсутствие форматированного вывода метрик, -0.5 за неэффективную реализацию метрик, -2 за отсутствие лучшего k и беспорядок в функции по его поиску)
- 1.5 - 0/2 (нет форматирования вывода метрик и неудачный анализ, ответ "тут что-то не так" не прокатит, надо код дебажить!)
- 2.1 - 3/4 (за пайплайн +2 и за отсутствие скейлинга и трансформации категориальной фичи -1)
- 2.2 - 1/1
- 2.3 - 1.75/3 (коэффициент детерминации неправильный, -0.25 за неэффективную реализацию точности)
- 2.4 - 2/2
- 3 - 0.5

ШТРАФ: У тебя нет отдельной папки с кодом и с данными (в данном задании она не то, чтобы нужна, поэтому это ладно), я вынужден снять за это **полбалла**, так как структура проекта должна отделять код от данных и других частей (конфигов, результатов и прочее)

TOTAL: 9 + 2.5 - 0.5 = 11 баллов